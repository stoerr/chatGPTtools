<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Persönlicher ChatGPT für THEUSERNAME</title>
    <meta name="description" content="Personalizierter ChatGPT für THEUSERNAME, mit begrenztem Gedächtnis">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <!-- Styling that makes divs of the classes 'message assistant' white and 'message user' light gray  -->
    <style>
        .message.user {
            border-radius: 5px;
            background-color: lightgray;
        }
    </style>
</head>
<body>
<div class="container-xxl">
    <div class="row">
        <div class="col-xs-12">
            <div class="card">
                <div class="card-header">
                    <h1 class="text-center">THECHATGPTNAME für THEUSERNAME</h1>
                </div>
                <div class="card-body">
                    <div id="initialprompt" style="display:none;">THEINITIALPROMPT</div>
                    <div id="messagecontainer">
                    </div>
                    <div class="spinner-border mb-2 collapse" role="status">
                        <span class="sr-only">Loading...</span>
                    </div>
                    <div class="mb-3 input">
                        <textarea class="form-control" id="nextmessage" rows="5" autofocus></textarea></div>
                    <div class="buttons d-flex">
                        <div class="flex-grow-1">
                            <button type="button" class="btn btn-primary submitbutton" onclick="submit()">Abschicken
                            </button>
                            <!-- <button type="button" class="btn btn-primary" id="speak"
                                    title="Zum Sprechen Knopf drücken und nach dem Sprechen wieder loslassen.">Sprechen
                            </button> -->
                            <button type="button" class="btn btn-primary" onclick="reset()">Leeren</button>
                        </div>
                        <i class="fa fa-angle-down collapse" id="memorydown"
                           onclick="$('#memoryframe').slideDown(); $('#memoryup').show(); $('#memorydown').hide(); "></i>
                        <i class="fa fa-angle-up" id="memoryup"
                           onclick="$('#memoryframe').slideUp(); $('#memoryup').hide(); $('#memorydown').show(); "></i>
                    </div>
                    <div id="template" class="message"></div>
                </div>
            </div>
        </div>
    </div>
    <div id="memoryframe" class="row collapse">
        <div class="col-xs-12">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">
                        <button type="button" class="btn-close" aria-label="Close"
                                onclick="$('#memoryframe').slideUp()"></button>
                        Gedächtnis
                    </h5>
                    <p>Dies ist das "Gedächtnis" über frühere Konversationen,
                        das diese Seite ChatGPT zur Verfügung stellt,
                        und von ChatGPT immer wieder überarbeitet wird.</p>
                    <button type="button" class="btn btn-primary" onclick="resetMemory()">Gedächtnis leeren</button>
                </div>
                <div class="card-footer" id="memory">
                </div>
            </div>
        </div>
    </div>
</div>

<script src="//cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
        crossorigin="anonymous"></script>
<script
        src="//code.jquery.com/jquery-3.6.4.min.js"
        integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8="
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/showdown@2.1.0/dist/showdown.min.js"
        integrity="sha384-GP2+CwBlakZSDJUr+E4JvbxpM75i1i8+RKkieQxzuyDZLG+5105E1OfHIjzcXyWH"
        crossorigin="anonymous"></script>
<script>
    const user = 'user';
    const assistant = 'assistant';
    const systemmessage = $('#initialprompt').text() || 'Sei ein hilfreicher Assistent';
    /** True when a request to ChatGPT is in flight. */
    var inprocess = false;

    /** Array of messages that have not yet been summarized */
    const unsummarizedMessages = new LocalStoreBackedVariable("THEDATASTOREPREFIX-chatgpt-personal-unSummarizedMessages", []);
    /** A summary of previous conversations with the user, generated by ChatGPT. Meant to aid the assistant in this conversation. */
    const longTermMemory = new LocalStoreBackedVariable("THEDATASTOREPREFIX-chatgpt-personal-longTermMemory", "");
    const messagesInProcessing = new LocalStoreBackedVariable("THEDATASTOREPREFIX-chatgpt-personal-messagesInProcessing", []);
    const chathistory = new LocalStoreBackedVariable("THEDATASTOREPREFIX-chatgpt-personal-chathistory", []);
    const chathistoryUsermsg = new LocalStoreBackedVariable("THEDATASTOREPREFIX-chatgpt-personal-chathistoryUsermsg", []);
    const data = {
        longTermMemory: longTermMemory,
        messagesInProcessing: messagesInProcessing,
        chathistory: chathistory,
        chathistoryUsermsg: chathistoryUsermsg,
        unsummarizedMessages: unsummarizedMessages
    } // = for easier access in the console.

    const introducingLTMPrompt = "Der folgende Text enthält Hintergrundinformationen über den Benutzer. Bitte verwende diese Informationen, um Deine Antworten im Gespräch auf den Nutzer anzupassen:\n\n";
    const initialMessage = "THEINITIALMESSAGE";

    /** Clear all LocalStoreBackedVariable */
    function resetMemory() {
        unsummarizedMessages.clear();
        messagesInProcessing.clear();
        longTermMemory.clear();
        $('#memory').html('');
    }

    // on document ready, focus the textarea
    $(document).ready(function () {
        summarizeLongTermMemory();
        sayHi();

        $question = $('#nextmessage');
        $question.focus();

        // make key binding for $question so that pressing enter submits the question
        $question.keypress(function (e) {
            if (e.which === 13 && !e.shiftKey) {
                submit();
                return false;
            }
        });

        chathistory.limitArraySize();
        chathistoryUsermsg.limitArraySize();

        // speechListener($('#nextmessage'), $('#speak'));
    });

    function waiting(finshed) {
        inprocess = finshed;
        $('.submitbutton').prop('disabled', finshed);
        if (finshed) {
            $('.spinner-border').show();
        } else {
            $('.spinner-border').hide();
        }
    }

    /** Sends the systemmessage and 'Hi!' as user message, and appends the result. */
    function sayHi() {
        // addMessage('assistant', 'Hi! (FIXME reenable request)');
        let messages = [{role: 'system', content: systemmessage}, {role: user, content: 'Hi!'}];
        submitToGPT(messages, processResult, onError, {}, true);
    }

    function storeForSummary(message) {
        unsummarizedMessages.push(message);
    }

    function collectContentForSummarization(messagesToSummarize) {
        var summarizationprompt = "";
        const ltm = longTermMemory.get();
        if (ltm && ltm.trim()) {
            summarizationprompt += "Eine Zusammenfassung von ChatGPT zu früheren Chats mit mir ist wie folgt:\n\"";
            summarizationprompt += ltm;
            summarizationprompt += "\"\n\n";
        }
        summarizationprompt += "Die folgenden Nachrichten habe habe ich an danach an ChatGPT übermittelt:\n\n";
        summarizationprompt += messagesToSummarize.join("\n\nDas waren die Nachrichten, die ich an ChatGPT übermittelt habe.\n");
        return summarizationprompt;
    }

    /**
     * This takes unsummarized messages from previous calls to this page (which are in unsummarizedMessages )
     * and sends that together with the current longTermMemory to ChatGPT, which will return the new contents of longTermMemory.
     * Unfortunately the call to ChatGPT takes a while, so we need to take some precautions that we don't discard messages
     * that are added to unsummerizedMessages while the call is in flight. And also it could be aborted, so we need to
     * still store the messages from unsummarizedMessages and only delete them after the call has finished.
     * This is done with the following strategy (in pseudo code):
     */
    function summarizeLongTermMemory() {
        $('#memory').text("(Alt:) " + longTermMemory.get());

        let messagesToSummarize = messagesInProcessing.get();
        messagesToSummarize = messagesToSummarize.concat(unsummarizedMessages.get());
        messagesInProcessing.set(messagesToSummarize);
        unsummarizedMessages.clear();

        // FIXME evtl. Beispiele in der Anfrage angeben.
        if (messagesToSummarize.length > 5) {
            var summarizationprompt = collectContentForSummarization(messagesToSummarize);
            var messages = [{
                role: 'system',
                content: "Bei der Anforderung \"Zusammenstellung\" erstelle eine Informationszusammenstellung mit soviel wie möglich Informationen für ChatGPT, die für spätere Konversationen des Nutzers mit ChatGPT nützlich sein könnten. Bitte diese Zusammenstellung auf Deutsch als Fliesstext ohne jegliche erläuternde Kommentare. Diese Zusammenstellung ist für den Nutzer unsichtbar, und darf also keine Informationen für den Nutzer enthalten, sondern ist nur für ChatGPT zur Personalisierung und Kontinuität gedacht. Falls genug Platz ist, dann bitte die Zusammenstellung lassen wie sie ist, damit nichts verloren geht, und nur Zusätze entsprechend den folgenden Nachrichten anfügen."
            },
                {
                    role: user, content: summarizationprompt +
                        "Sehr umfassende Zusammenstellung von allen daraus entnehmbaren Hintergrundinformationen über diesen Nutzer, die für ChatGPT für zukünftige Gespräche zur Personalisierung und Gesprächskontinuität nützlich sein könnte, im Fliesstext (keine Stichpunkte):"
                }];
            console.log("Updating LTM: " + JSON.stringify(messages));
            submitToGPT(messages, receiveLongTermMemorySummary, onError, {max_tokens: 1000}, true);
        }
    }

    function receiveLongTermMemorySummary(data) {
        for (const choice of data.choices) {
            let message = choice.message.content;
            console.log("Received LTM: " + message);
            longTermMemory.set(message);
            messagesInProcessing.clear();
            $('#memory').text(message);
        }
    }

    function submit() {
        if (inprocess) {
            return;
        }
        let message = $question.val();
        storeForSummary(message);
        chathistoryUsermsg.push({role: user, content: message});
        chathistory.push({role: user, content: message});

        addMessage(user, message);
        let messages = [{role: 'system', content: systemmessage},
            {role: user, content: introducingLTMPrompt + "\"" + longTermMemory.get() + "\""},
            {role: user, content: initialMessage}];
        // collect all div.message , role as in the class, content as in the message attribute
        $('#messagecontainer').children('.message').each(function () {
            messages.push({role: $(this).attr('class').split(' ')[1], content: $(this).attr('message')});
        });
        $('#nextmessage').val('');
        submitToGPT(messages, processResult, onError);
    }

    function reset() {
        $('#nextmessage').val('');
        $('#messagecontainer').empty();
        sayHi();
    }

    /** copies #template into #messagecontainer and sets the id and class accordingly - role is added to the divs class.  */
    function addMessage(role, message) {
        let template = $('#template');
        let messagecontainer = $('#messagecontainer');
        let newMessage = template.clone();
        let lastMessage = messagecontainer.children('.message').last();
        let lastMessageId = lastMessage.attr('id') || 'msg-0';
        let newMessageId = 'msg-' + (parseInt(lastMessageId.split('-')[1]) + 1);
        newMessage.attr('id', newMessageId);
        newMessage.attr('class', 'message ' + role);
        newMessage.attr('message', message);
        newMessage.attr('data-role', role);
        var converter = new showdown.Converter();
        let html = converter.makeHtml(message);
        html = html.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1">$1</a>');
        newMessage.html(html);
        newMessage.appendTo(messagecontainer);
    }

    /** Submits a message array via $.ajax to https://api.openai.com/v1/chat/completions .
     * @param messages array of  in the format {"role": type, "content": message}
     * @param resultcallback gets the data from the result
     * @param errorcallback in case of errors.
     * @param additionalProperties additional properties to be added to the request.
     * @param siderequest if true, we don't set waiting() to true
     * */
    function submitToGPT(messages, resultcallback, errorcallback, additionalProperties, siderequest) {
        function isRetryableError(jqXHR, status, errorThrown) {
            return jqXHR.status === 429;
        }

        const hashCode = (s) => {
          return s.split('').reduce( (a, b) => {
            a = 92821 * a + b.charCodeAt(0);
            return a & a;
          }, 0);
        }

        var api_key = 'XXXKEYXXX' || localStorage.getItem('openai_api_key');
        if (!api_key) {
            api_key = prompt("Please enter your API key, which you can create in your profile at https://platform.openai.com/");
            if (api_key) {
                localStorage.setItem('openai_api_key', api_key);
            }
        }

        function makeCall(resultcb, errorcb) {
            if (!siderequest) {
                waiting(true);
            }
            console.log("Sending: " + JSON.stringify(messages));
            var request = {
                url: 'https://api.openai.com/v1/chat/completions',
                type: 'POST',
                dataType: 'json',
                headers: {
                    'Authorization': 'Bearer ' + api_key,
                    'Content-Type': 'application/json',
                },
                data: JSON.stringify({
                    model: "gpt-4o-mini",
                    user: '' + hashCode('THEUSERNAME'),
                    messages: messages,
                }),
                success: resultcb,
                error: errorcb,
                timeout: 60000 // the API takes sometimes a pretty wild time to respond; since we're interactive we give up here.
            };
            if (additionalProperties) {
                for (const [key, value] of Object.entries(additionalProperties)) {
                    request[key] = value;
                }
            }
            return $.ajax(request);
        }

        retrialStrategy(makeCall, isRetryableError, resultcallback, errorcallback);
    }

    /** Adds successfully received assistant messages. */
    function processResult(data) {
        console.log("Received: " + JSON.stringify(data));
        for (const choice of data.choices) {
            let message = choice.message.content;
            addMessage(assistant, message);
            chathistory.push({assistant: message});
        }
        waiting(false);
    }

    /** Error handler for ChatGPT */
    function onError(xhr, status, error) {
        $('button.submitbutton').prop('disabled', false);
        var errorText = xhr.responseJSON ? JSON.stringify(xhr.responseJSON) : status || error;
        console.error('Error: ', errorText, xhr);
        addMessage(assistant, 'Error: ' + errorText);
        waiting(false);
    }

    /** Class that simulates a variable that is actually stored as JSON in localStore at the given key.
     * Methods: read reads the value from localStore on each access, write sets a new value back, clear clears it. */
    function LocalStoreBackedVariable(key, defaultValue) {

        this.get = function () {
            let value = localStorage.getItem(key);
            if (value) {
                return JSON.parse(value);
            } else {
                return defaultValue || null;
            }
        };

        this.set = function (value) {
            if (value) {
                console.log("Setting " + key); //  + " to " + JSON.stringify(value));
                localStorage.setItem(key, JSON.stringify(value));
            } else {
                clear();
            }
        };

        this.clear = function () {
            console.log("Clearing " + key);
            localStorage.removeItem(key);
        };

        this.push = function (value) {
            let array = this.get();
            array.push(value);
            this.set(array);
        }

        /** We check whether the JSON size surpasses 100kbytes, and if it does we remove the first third of messages from the array. */
        this.limitArraySize = function () {
            var rawString = localStorage.getItem(key)
            if (rawString && rawString.length > 100 * 1024) {
                let array = this.get();
                let third = Math.floor(array.length / 3);
                array.splice(0, third);
                this.set(array);
            }
        }

    }

    function getUserMessagesFromHistoryAsPlainArray() {
        let userMessages = [];
        for (const message of chathistory.get()) {
            if (message.role === user) {
                userMessages.push(message.content);
            }
        }
        return userMessages;
    }

    /** Elaborate strategy to speed up things, since the API is wildly unpredictable in it's timing and sometimes we need
     * to retry because of the rate limit. We guarantee that either successCallback or errorCallback is called exactly once
     * in time, never both. So we will do several things here.
     * 1. we will make parallel calls after a while, up to 3, starting after 10 seconds and using iterative doubling of the time.
     * The first call that succeeds will abort all other calls.
     * 2. if one of the calls fails with an isRetryable error, we will also retry after that time, with iterative doubling.
     * @param function makeCall the function to call, which should return a promise with an .abort() function. It has the arguments successCallback and errorCallback.
     * It has to guarantee it will call either of them once in time, but not both.
     * @param function isRetryableError a function that takes the same arguments as the error callback and returns true if the error is retryable
     * @param function successCallback the success callback that is called once if one of the calls succeeds
     * @param function errorCallback the error callback that is called once if all calls fail
     */
    function retrialStrategy(makeCall, isRetryable, successCallback, errorCallback) {
        const maxTries = 4;
        const maxInflightCalls = 3;
        var timeNextStep = 10000; // for iterative doubling
        var inflightCalls = []; // the results of makeCall which we could .abort() later
        var runningTimeout = null; // the timeout that will trigger the next step
        var done = false; // whether we have called either success or error callback
        var tries = 0;

        triggerCall();
        setTimeout(startNextStep, timeNextStep);

        function triggerCall() {
            if (tries >= maxTries) {
                console.log("Huh? " + tries + " retries.");
                return;
            }
            tries += 1;
            console.log("Triggering call no. " + tries);
            let call = makeCall((...args) => onSuccess(call, ...args), (...args) => onError(call, ...args));
            inflightCalls.push(call);
        }

        function onSuccess(call, ...args) {
            inflightCalls = inflightCalls.filter(c => c !== call);
            if (!done) {
                done = true;
                cleanup();
                successCallback(...args);
            }
        }

        function onError(call, ...args) {
            inflightCalls = inflightCalls.filter(c => c !== call);
            if (!isRetryable(...args)) {
                console.log("Not retryable, aborting: " + JSON.stringify(args));
                if (!done) {
                    done = true;
                    cleanup();
                    errorCallback(...args);
                }
            } else if (!done && inflightCalls.length === 0 && tries >= maxTries) {
                done = true;
                cleanup();
                errorCallback(...args);
            }
        }

        function startNextStep() {
            if (!done && inflightCalls.length < maxInflightCalls) {
                if (tries >= maxTries) {
                    console.log("Giving up after " + tries + " retries.");
                    return;
                }
                triggerCall();
                timeNextStep *= 2;
                runningTimeout = setTimeout(startNextStep, timeNextStep);
            }
        }

        function cleanup() {
            if (runningTimeout) {
                clearTimeout(runningTimeout);
            }
            runningTimeout = null;
            for (const call of inflightCalls) {
                call.abort();
            }
            inflightCalls = [];
        }
    }

    function speechListener($textArea, $speakButton) {
        try {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            recognition.lang = 'de-DE';
            recognition.interimResults = true;
            var insertPosition = 0;
            var lastResultLength = 0;

            $speakButton.on('mousedown', () => {
                insertPosition = $textArea[0].selectionEnd;
                lastResultLength = 0;
                recognition.start();
                console.log("Recognition started");
            });

            $speakButton.on('mouseup', () => {
                recognition.stop();
                console.log("Regognition stopped");
            });

            recognition.addEventListener('result', (event) => {
                const isFinal = event.results[event.resultIndex].isFinal;
                const result = event.results[event.resultIndex][0].transcript + " ";
                console.log('result: ' + result + ' (isFinal: ' + isFinal + ')');

                $textArea.val(
                    $textArea.val().slice(0, insertPosition) +
                    result +
                    $textArea.val().slice(insertPosition + lastResultLength)
                );
                lastResultLength = result.length;

                $textArea[0].setSelectionRange(insertPosition, insertPosition + lastResultLength);
                $textArea.focus();
            });

            recognition.addEventListener('end', () => {
                console.log("Recognition ended");
                $speakButton.removeClass('active');
            });

        } catch (e) {
            console.log("Speech recognition not supported: " + e);
            $speakButton.hide();
        }

        return this;
    }

</script>
</body>
</html>
