#!/bin/bash
# Reproduces https://simonwillison.net/2024/Oct/27/llm-jq/ - what a great idea by Simon Willison!

# print usage if there are no arguments $1 is -h or --help

function usage() {
  echo "Extracts from a JSON file read from stdin by applying a jq command generated by ChatGPT from your prompt"
  echo "Usage e.g.: cat jsonfile | $0 prompt"
  echo "Additional options:"
  echo "  -h, --help: print this help message"
  echo "  -v, --verbose: print the request sent to the LLM"
  echo "  -s, --silent: do not print the command run with jq"
}

if [ "$#" -lt 1 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
  usage
  exit 0
fi

# parse the options
verbose=""
silent=false
while [ "$#" -gt 0 ]; do
  case $1 in
    -v|--verbose) verbose="-v"; shift ;;
    -s|--silent) silent=true; shift ;;
    -h|--help) usage; exit 0 ;;
    *) break ;;
  esac
done

prompt="$*"

jqgenerateprompt=$(cat << EOF
Based on the printed JSON snippet and the desired query, write a jq program

Return only the jq program to be executed as a raw string, no string delimiters wrapping it, no yapping, no markdown, no fenced code blocks, what you return will be passed as filter argument to jq directly. For example, if the user asks: extract the name of the first person You return only: .people[0].name
EOF
)

tmpfil=$(mktemp -u).json
trap 'rm -f $tmpfil' EXIT

# read the JSON from stdin
cat > $tmpfil
if [ "$?" -ne 0 ]; then
  echo "Error reading JSON from stdin"
  exit 1
fi

# generate the jq command
jqcmd=$(head -c 1000 $tmpfil | chatgpt $verbose -f - -s "$jqgenerateprompt" "$prompt")
if [ "$?" -ne 0 ]; then
  echo "Error generating jq command"
  exit 1
fi

if [ "$silent" = false ]; then
  echo "jq $jqcmd"
fi

# run the jq command
jq "$jqcmd" $tmpfil
result=$?
if [ "$result" -ne 0 ]; then
  echo "Error $result running jq command"
  exit $?
fi
