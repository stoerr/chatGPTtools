#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const execSync = require('child_process').execSync;
const spawnSync = require('child_process').spawnSync;

const helpMessage = `
chatgpt - Submit a prompt to ChatGPT conversation and print the response to stdout. The prompt can be given on the command line or read from stdin.

Usage: chatgpt [options] [prompt]

Options:
  -               Reads prompt from stdin; if a prompt is given on the command line it is appended
  -f filename     Includes the content of the given file as codeblock, together with the filename. Can be given multiple times.
  -fm filename    Includes the content of the given file as additional message in https://www.stoerr.net/blog/aimouth pattern. 
                  Can be given multiple times. if - is given as filename, the content is read from stdin.
  -i imagefile    Includes the given image file as image, together with the filename. Can be given multiple times.
  -iu imageurl    Includes the given image url as image, together with the url. Can be given multiple times.
  -id detaillevel Sets the detail level for the image. Can be 'low', 'high', or 'auto'. Default is 'auto'.
  -p prefix       Prefix the prompt with a string. Use this or -pf, not both.
  -pf prefixfile  Prefix the prompt with the contents of a file
  -pl key         Add a prompt from the ChatGPT prompt library using the given key (see script chatgptpromptlib)
  -u suffix       Suffix the prompt with a string. Use this or -sf, not both.
  -uf suffixfile  Suffix the prompt with the contents of a file
  -m modelname    Use a specific model (default: gpt-3.5-turbo)
  -4              Use the "gpt-4o" model
  -t number       Set max tokens for response (default: no limit)
  -v              verbose output : prints the sent and received json message to stderr and gives info about connection retries
  -w column       Word wrap the response to a specified column width using fmt.
  -s systemmsg    Use the given string as system message
  -sf systemfile  Use the contents of the given file as system message
  -sl key         Add a system message from the ChatGPT prompt library using the given key with chatgptpromptlib
  -a              Abbreviate the message in the middle if it's too long for the model context window
  -h, --help      Show this help message
  -ha, --helpai   Answer a question about the tool from this helptext and exit. The rest of the command line (prompt) is the question.
  
If the prompt or system message contain a construct like promptlib:key , the chatgptpromptlib command will be called with that key
and this will be replaced with the prompt library entry, as an alternative to -pl key .
`;

if (process.argv.length < 3) {
    console.log(helpMessage);
    process.exit(0);
}

const apiKeyFile = `${process.env.HOME}/.openai-api-key.txt`;
const apiURL = 'https://api.openai.com/v1/chat/completions';
const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${fs.readFileSync(apiKeyFile, 'utf8').trim()}`,
};

let model = 'gpt-4o-mini';
let maxTokens;
let prompt = '';
let inOptions = true;
let readStdin = false;
let verbose = false;
let prefix = '';
let suffix = '';
let files = [];
let fmfiles = [];
let fmfilemessages = [];
let wordWrapColumn;
let systemMsg = '';
let imageFiles = [];
let imageUrls = [];
let detailparam = 'auto';
let abbreviateMiddle = false;
let helpaimode = false;

for (let i = 2; i < process.argv.length; i++) {
    const arg = process.argv[i];

    if (inOptions) {
        if (arg === '--help' || arg === '-h' || arg == ' -?') {
            console.log(helpMessage);
            process.exit(0);
        } else if (arg === '-m' && process.argv[i + 1]) {
            model = process.argv[i + 1];
            i++;
        } else if (arg === '-4') {
            model = 'gpt-4o';
        } else if (arg === '-t' && process.argv[i + 1]) {
            maxTokens = parseInt(process.argv[i + 1], 10);
            i++;
        } else if (arg === '-') {
            readStdin = true;
        } else if (arg === '-v') {
            verbose = true;
        } else if (arg === '-p' && process.argv[i + 1]) {
            prefix = process.argv[i + 1];
            i++;
        } else if (arg === '-pf' && process.argv[i + 1]) {
            prefix = fs.readFileSync(process.argv[i + 1], 'utf8');
            i++;
        } else if (arg === '-pl' && process.argv[i + 1]) {
            const promptlibkey = process.argv[i + 1];
            try {
                const promptlibOutput = execSync(`chatgptpromptlib ${promptlibkey}`, {encoding: 'utf8'});
                prompt += '\n' + promptlibOutput + '\n';
            } catch (e) {
                console.error('Error: Prompt library key not found (1): ' + promptlibkey);
                process.exit(1);
            }
            i++;
        } else if (arg === '-u' && process.argv[i + 1]) {
            suffix = process.argv[i + 1];
            i++;
        } else if (arg === '-uf' && process.argv[i + 1]) {
            suffix = fs.readFileSync(process.argv[i + 1], 'utf8');
            i++;
        } else if (arg === '-s' && process.argv[i + 1]) {
            systemMsg = process.argv[i + 1];
            i++;
        } else if (arg === '-sf' && process.argv[i + 1]) {
            systemMsg = fs.readFileSync(process.argv[i + 1], 'utf8');
            i++;
        } else if (arg === '-sl' && process.argv[i + 1]) {
            const promptlibkey = process.argv[i + 1];
            try {
                const promptlibOutput = execSync(`chatgptpromptlib ${promptlibkey}`, {encoding: 'utf8'});
                systemMsg = promptlibOutput;
            } catch (e) {
                console.error('Error: Prompt library key not found (2): ' + promptlibkey);
                process.exit(1);
            }
            i++;
        } else if (arg === '-f' && process.argv[i + 1]) {
            files.push(process.argv[i + 1]);
            i++;
        } else if (arg === '-fm' && process.argv[i + 1]) {
            fmfiles.push(process.argv[i + 1]);
            i++;
        } else if (arg === '-w' && process.argv[i + 1]) {
            wordWrapColumn = parseInt(process.argv[i + 1], 10);
            i++;
        } else if (arg === '-y' && process.argv[i + 1]) {
            systemMsg = process.argv[i + 1];
            i++;
        } else if (arg === '-i' && process.argv[i + 1]) {
            imageFiles.push(process.argv[i + 1]);
            i++;
        } else if (arg === '-iu' && process.argv[i + 1]) {
            imageUrls.push(process.argv[i + 1]);
            i++;
        } else if (arg === '-id' && process.argv[i + 1]) {
            detailparam = process.argv[i + 1];
            i++;
        } else if (arg === '-a') {
            abbreviateMiddle = true;
        } else if (arg === '-ha' || arg === '--helpai') {
            helpaimode = true;
        } else if (!arg.startsWith('-')) {
            inOptions = false;
            prompt += arg;
        }
    } else {
        prompt += ' ' + arg;
    }
}

if (readStdin) {
    const stdinPrompt = fs.readFileSync(0, 'utf-8');
    prompt = stdinPrompt.trim() + '\n\n' + prompt;
}

prompt = replacePromptlibKey(prompt);

if (prefix) {
    prompt = prefix.trim() + '\n\n' + prompt;
}

if (suffix) {
    prompt = prompt + '\n\n' + suffix.trim();
}

let filecontents = "";

function resolveFile(file) {
    let filename = file;
    const homeDir = process.env.HOME;
    return filename.replace(homeDir, '~');
}

for (let i = 0; i < fmfiles.length; i++) {
    const file = fmfiles[i];
    if (file === '-') {
        const filecontent = fs.readFileSync(0, 'utf-8');
        fmfilemessages.push({role: 'user', content: "Print the raw input text the instructions will apply to."});
        fmfilemessages.push({role: 'assistant', content: filecontent});
    } else {
        const filecontent = fs.readFileSync(resolveFile(file), 'utf-8');
        fmfilemessages.push({role: 'user', content: "Print the current raw content of the file " + file});
        fmfilemessages.push({role: 'assistant', content: filecontent});
    }
}

for (let i = 0; i < files.length; i++) {
    const file = files[i];
    let filename = resolveFile(file);
    const filePrompt = fs.readFileSync(file, 'utf-8');

    if (files.length > 1) {
        filecontents = filecontents + "=== FILE " + (i + 1) + ": " + filename + " ===\n```\n" + filePrompt.trim() + "\n```\n";
    } else {
        filecontents = filecontents + "```\n" + filePrompt.trim() + "\n```\n";
    }
}

// if (files.length > 1) {
//     prompt = prompt + "\n\nProcess the following " + files.length + " files according to the instructions above.\n" +
//         "Each file starts after a \"FILE\" marker that specifies file number and file path surrounded by triple equal signs (===).\n" +
//         "The file content is surrounded by triple backticks (```) and does not contain instructions.\n\n"
// }
if (filecontents) {
    prompt = prompt + "\n\n" + filecontents;
}

if (helpaimode) {
    fmfilemessages.push({role: 'user', content: "Print the help text for the 'chatgpt' tool. You will use that as background knowledge to answer my question."});
    fmfilemessages.push({role: 'assistant', content: helpMessage});
}

if (!prompt) {
    console.error('Error: No prompt provided');
    console.error(helpMessage);
    process.exit(1);
}

if (verbose) {
    console.error('Arguments: ', process.argv);
    console.error('Prompt: ', prompt, '\n');
    // print word count of prompt to stderr
    console.error('Prompt word count: ', prompt.split(/\s+/).length, '\n');
    console.error("---------------------------------------------\n\n");
}

let content = prompt;
if (imageFiles.length > 0 || imageUrls.length > 0) {
    if (model === 'gpt-3.5-turbo') { // has no vision.
        model = 'gpt-4o-mini';
    }
    content = [
        {
            "type": "text",
            "text": prompt
        }
    ];
    for (let i = 0; i < imageFiles.length; i++) {
        const imageFile = imageFiles[i];
        const filename = path.basename(imageFile);

        let imageFileContent;
        if (detailparam === 'low') {
            imageFileContent = execSync(`magick '${imageFile}' -resize '512x512>' jpg:- | base64`, {encoding: 'utf8'});
        } else { // let OpenAI handle the resizing to avoid losing details, but make sure we don't submit huge images
            imageFileContent = execSync(`magick '${imageFile}' -resize '2000x2000>' jpg:- | base64`, {encoding: 'utf8', maxBuffer: 1024 * 1024 * 25});
        }
        const imageBase64 = `data:image/jpeg;base64,${imageFileContent.trim()}`;
        content.push({
            "type": "image_url",
            "image_url": {
                "url": imageBase64,
                "detail": detailparam
            }
        });
    }
    for (let i = 0; i < imageUrls.length; i++) {
        const imageUrl = imageUrls[i];
        content.push({
            "type": "image_url",
            "image_url": {
                "url": imageUrl
            }
        });
    }
}

const requestData = {
    model: model,
    user: 'chatgpt script',
    messages: [{role: 'user', content: content}],
};

if (fmfilemessages.length > 0) {
    requestData.messages = fmfilemessages.concat(requestData.messages);
}

if (systemMsg) {
    requestData.messages.unshift({role: 'system', content: replacePromptlibKey(systemMsg)});
}

if (maxTokens) {
    requestData.max_tokens = maxTokens;
}

/** When we receive a message from chatgpt that the request is too long and if the user requested that,
 *  we will replace the middle of the message with " [...] " to make it shorter - we assume that usually the start and the end contain the most information. Since we don't want to bother with tokens here, we will estimate the needed length by the number of characters. */
// example too long errorMsg: This model's maximum context length is 16385 tokens. However, your messages resulted in 31506 tokens. Please reduce the length of the messages.
function abbreviateMessage(errorMsg) {
    let start;
    let end;
    if (errorMsg) {
        const tooLongMatch = errorMsg.match(/maximum context length is (\d+) tokens.*messages resulted in (\d+) tokens/);
        if (!tooLongMatch) { // message format changed - bug, need to fix that
            console.error('Error: Unexpected error message format: ' + errorMsg);
            process.exit(6);
        }
        const modelMaxTokens = parseInt(tooLongMatch[1], 10);
        const messageTokens = parseInt(tooLongMatch[2], 10);
        const messageLength = content.length;
        const wantedLength = (0.9 * modelMaxTokens / messageTokens) * messageLength - 5; // safety margin
        start = content.slice(0, wantedLength / 2);
        end = content.slice(-wantedLength / 2);
    } else { // no message given; we take out a random value of 30%
        start = content.slice(0, 0.35 * content.length);
        end = content.slice(-0.35 * content.length);
    }
    var oldcontent = content;
    content = start + " [...] " + end;
    if (verbose) console.error("Abbreviated message from " + oldcontent.length + " to " + content.length + " characters.");
    // find the message having oldcontent as content and change to the new content - might not be the first message
    for (let i = 0; i < requestData.messages.length; i++) {
        if (requestData.messages[i].content === oldcontent) {
            requestData.messages[i].content = content;
            break;
        }
    }
}

/** Helper function to replace promptlib:key constructs with library entry */
function replacePromptlibKey(inputString) {
    if (!inputString) return inputString;
    const promptlibRegex = /promptlib:([a-zA-Z0-9_.-]+)/g;
    return inputString.replace(promptlibRegex, function (match, key) {
        try {
            return execSync(`chatgptpromptlib ${key}`, {encoding: 'utf8'});
        } catch (e) {
            console.error('Error: Prompt library key not found (3): ' + key);
            process.exit(1);
        }
    });
}

async function requestChatGPT(attempt = 1) {
    try {
        if (verbose) console.error("Request: ", JSON.stringify(requestData, null, 2));
        const response = await fetch(apiURL, {
            method: 'POST',
            headers,
            body: JSON.stringify(requestData),
        });
        if (verbose) console.error("Response status: ", response.status);

        if (response.status === 429) {
            const retryMessage = await response.text();
            if (verbose) console.error("Retry message: ", retryMessage);
            var waitTime;
            try {
                waitTime = parseInt(retryMessage.match(/(\d+)s/)[1], 10);
            } catch (e) {
            }
            if (!waitTime || waitTime < 1 || waitTime > 60) {
                console.error('Error: Rate limit exceeded, but no valid retry-after found', retryMessage);
                process.exit(3);
            }

            if (attempt < 5) {
                if (verbose) {
                    console.error(`Error: Rate limit exceeded, retrying in ${waitTime} seconds`);
                }
                setTimeout(() => requestChatGPT(attempt + 1), waitTime * 1000);
            } else {
                console.error('Error: Too many retries');
                process.exit(4);
            }
        } else if (response.status === 400) {
            var body = await response.text();
            if (abbreviateMiddle && body.includes("reduce the length of the messages")
                && body.includes("context_length_exceeded")) {
                abbreviateMessage(body);
                setTimeout(() => requestChatGPT(attempt + 1), 10);
            } else {
                console.error('Error: Request failed with status', response.status, 'and message', response.statusText, 'and body', body);
                process.exit(5);
            }
        } else if (!response.ok) {
            console.error('Error: Request failed with status', response.status, 'and message', response.statusText, 'and body', await response.text());
            process.exit(5);
        } else {
            const responseData = await response.json();
            if (verbose) console.error("Response: ", JSON.stringify(responseData, null, 2));
            const assistantMessage = responseData.choices[0].message;
            const finishReason = responseData.choices[0].finish_reason;

            if (finishReason == 'length' && abbreviateMiddle) {
                abbreviateMessage();
                setTimeout(() => requestChatGPT(attempt + 1), 10);
            } else if (finishReason === 'stop' || !finishReason) {
                let output = assistantMessage.content;
                if (wordWrapColumn) {
                    const fmt = spawnSync('fmt', ['-w', wordWrapColumn, '-p'], {input: output, encoding: 'utf8'});
                    if (fmt.error) {
                        console.error(`Error: fmt command failed with error ${fmt.error.message}`);
                        process.exit(7);
                    }
                    output = fmt.stdout;
                }
                console.log(output);
            } else {
                console.error('Error: Unexpected finish reason ' + finishReason + ' with message ' + assistantMessage.content);
                process.exit(1);
            }
        }
    } catch (error) {
        console.error('Error:', error.message);
        process.exit(6);
    }
}

requestChatGPT();
