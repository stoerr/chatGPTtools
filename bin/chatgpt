#!/usr/bin/env node
const fs = require('fs');

const helpMessage = `
chatgpt - Submit a prompt to ChatGPT conversation and print the response to stdout. The prompt can be given on the command line or read from stdin.

Usage: chatgpt [options] [prompt]

Options:
  -               Reads prompt from stdin, instead of as an argument
  -f filename     Reads prompt from a file, including a frame naming the filename. Can be given multiple times.
  -p prefix       Prefix the prompt with a string. Use this or -pf, not both.
  -pf prefixfile  Prefix the prompt with the contents of a file
  -s suffix       Suffix the prompt with a string. Use this or -sf, not both.
  -sf suffixfile  Suffix the prompt with the contents of a file
  -m modelname    Use a specific model (default: gpt-3.5-turbo)
  -t number       Set max tokens for response (default: no limit)
  -v              verbose output : print prompt to stderr and info about connection retries
  --help          Show this help message
`;

if (process.argv.length < 3 || process.argv.includes('--help')) {
    console.log(helpMessage);
    process.exit(0);
}

const apiKeyFile = `${process.env.HOME}/.openaiapi`;
const apiURL = 'https://api.openai.com/v1/chat/completions';
const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${fs.readFileSync(apiKeyFile, 'utf8').trim()}`,
};

let model = 'gpt-3.5-turbo';
let maxTokens;
let prompt = '';
let inOptions = true;
let readStdin = false;
let verbose = false;
let prefix = '';
let suffix = '';
let files = [];

process.argv.slice(2).forEach((arg, i, argv) => {
    if (inOptions) {
        if (arg === '-m' && argv[i + 1]) {
            model = argv[i + 1];
            i++;
        } else if (arg === '-t' && argv[i + 1]) {
            maxTokens = parseInt(argv[i + 1], 10);
            i++;
        } else if (arg === '-') {
            readStdin = true;
        } else if (arg === '-v') {
            verbose = true;
        } else if (arg === '-p' && argv[i + 1]) {
            prefix = argv[i + 1];
            i++;
        } else if (arg === '-pf' && argv[i + 1]) {
            prefix = fs.readFileSync(argv[i + 1], 'utf8');
            i++;
        } else if (arg === '-s' && argv[i + 1]) {
            suffix = argv[i + 1];
            i++;
        } else if (arg === '-sf' && argv[i + 1]) {
            suffix = fs.readFileSync(argv[i + 1], 'utf8');
            i++;
        } else if (arg === '-f' && argv[i + 1]) {
            files.push(argv[i + 1]);
            i++;
        } else if (!arg.startsWith('-')) {
            inOptions = false;
            prompt += arg;
        }
    } else {
        prompt += ' ' + arg;
    }
});

if (readStdin) {
    const stdinPrompt = fs.readFileSync(0, 'utf-8');
    prompt = stdinPrompt.trim() + '\n\n' + prompt;
}

for (let i = 0; i < files.length; i++) {
    const file = files[i];
    var filename = file;
    // if filename contains users homedir, replace that by tilde
    const homeDir = process.env.HOME;
    filename = filename.replace(homeDir, '~');
    const filePrompt = fs.readFileSync(file, 'utf-8');
    prompt = '>>>>>>>> start of file ' + filename + ' >>>>>>>>\n' +
        filePrompt.trim() +
        '\n<<<<<<<< end of file ' + filename + ' <<<<<<<<\n\n' +
        '\n\n' + prompt;
}

if (prefix) {
    prompt = prefix.trim() + '\n\n' + prompt;
}

if (suffix) {
    prompt = prompt + '\n\n' + suffix.trim();
}

if (!prompt) {
    console.error('Error: No prompt provided');
    process.exit(1);
}

if (verbose) {
    console.error('Prompt: ', prompt, '\n');
    // print word count of prompt to stderr
    console.error('Prompt word count: ', prompt.split(/\s+/).length, '\n');
}

const requestData = {
    model: model,
    user: 'chatgpt script',
    messages: [{role: 'user', content: prompt}],
};

if (maxTokens) {
    requestData.max_tokens = maxTokens;
}

async function requestChatGPT(attempt = 1) {
    try {
        const response = await fetch(apiURL, {
            method: 'POST',
            headers,
            body: JSON.stringify(requestData),
        });

        if (response.status === 429) {
            const retryMessage = await response.text();
            const waitTime = parseInt(retryMessage.match(/(\d+)s/)[1], 10);

            if (attempt < 5) {
                if (verbose) {
                    console.error(`Error: Rate limit exceeded, retrying in ${waitTime} seconds`);
                }
                setTimeout(() => requestChatGPT(attempt + 1), waitTime * 1000);
            } else {
                console.error('Error: Too many retries');
                process.exit(3);
            }
        } else if (!response.ok) {
            console.error('Error: Request failed with status', response.status, 'and message', await response.text());
            process.exit(3);
        } else {
            const responseData = await response.json();
            const assistantMessage = responseData.choices[0].message;
            const finishReason = responseData.choices[0].finish_reason;

            if (finishReason === 'stop') {
                console.log(assistantMessage.content);
            } else {
                console.error('Error: Unexpected finish reason');
                process.exit(1);
            }
        }
    } catch (error) {
        console.error('Error:', error.message);
        process.exit(3);
    }
}

requestChatGPT();

/** This was created by ChatGPT-4 with the following prompt and was slightly edited and bugfixed by me:
 *
 * Prompt:
 *
 * Please generate a script for the command line for the following task, runnable on a MacBook Pro with Apple M1 Max, that is, arm64 architecture, and MacOS Ventura 13.3.1 . It can be either a bash script using any of the normally present command line tools or what is installable with homebrew, or a NodeJS script for version 19.5.0 . If NodeJS, it should not require installing any additional libraries, and be done as executable using the shebang to start node, no suffix .js in the filename required. If called without arguments or with the argument --help, the script should print a description that explains what it does, and what arguments it expects. Important: the usage printed at --help must include a description of what the script does!
 *
 * The name of the script is chatgpt. It should submit a single message to ChatGPT and print the answer to stdout. It should be done using NodeJS using fetch.
 *
 * In addition to option --help, it should have the following command line arguments:
 * - if it gets a single dash, that is a `-` , it should read the prompt from stdin. Otherwise it should take the whole rest of the
 *   command line except the options as prompt to send to ChatGPT.
 * - if it gets `-m modelname` it should use modelname as value of the model attribute in the request, instead of the default gpt-3.5-turbo
 * - if it gets `-t number` it should transmit the given number as 'max_tokens' in the request.
 *
 * It should access the ChatGPT chat completions API at https://api.openai.com/v1/chat/completions . The API key should be read from file ~/.openaiapi .
 *
 * The request looks like:
 * {"model":"gpt-3.5-turbo","messages":[{"role":"user","content":"This is the promt to submit to ChatGPT"}]}
 *
 * A successful response is like
 *   {
 *    'choices': [
 *      {
 *       'message': {
 *         'role': 'assistant',
 *         'content': 'This is the response to extract and print to stdout'},
 *       'finish_reason': 'stop',
 *      }
 *     ]
 *   }
 *
 * If the finish_reason is something other than stop, then print an error message to stderr and abort with exit code 1 .
 *
 * If the request is not successful and has status code 429 then look for a String like "Please try again in 20s." (the number 20 might vary) and wait for that many seconds and then retry, but at most 5 times. If the status code is other than 429 for an unsuccessful response, abort with exit code 3 .
 */
