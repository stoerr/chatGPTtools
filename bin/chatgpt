#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

const helpMessage = `
chatgpt - Submit a prompt to ChatGPT conversation and print the response to stdout. The prompt can be given on the command line or read from stdin.

Usage: chatgpt [options] [prompt]

Options:
  -               Reads prompt from stdin, instead of as an argument
  -f filename     Reads prompt from a file, including a frame naming the filename. Can be given multiple times.
  -fp filepattern Searches in the current directory and subdirectories for files matching this pattern - it's an error if there are several. Otherwise like -f.
  -p prefix       Prefix the prompt with a string. Use this or -pf, not both.
  -pf prefixfile  Prefix the prompt with the contents of a file
  -s suffix       Suffix the prompt with a string. Use this or -sf, not both.
  -sf suffixfile  Suffix the prompt with the contents of a file
  -m modelname    Use a specific model (default: gpt-3.5-turbo)
  -t number       Set max tokens for response (default: no limit)
  -v              verbose output : print prompt to stderr and info about connection retries
  --help          Show this help message
`;

if (process.argv.length < 3 || process.argv.includes('--help')) {
    console.log(helpMessage);
    process.exit(0);
}

const apiKeyFile = `${process.env.HOME}/.openaiapi`;
const apiURL = 'https://api.openai.com/v1/chat/completions';
const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${fs.readFileSync(apiKeyFile, 'utf8').trim()}`,
};

let model = 'gpt-3.5-turbo';
let maxTokens;
let prompt = '';
let inOptions = true;
let readStdin = false;
let verbose = false;
let prefix = '';
let suffix = '';
let files = [];

for (let i = 2; i < process.argv.length; i++) {
    const arg = process.argv[i];

    if (inOptions) {
        if (arg === '-m' && process.argv[i + 1]) {
            model = process.argv[i + 1];
            i++;
        } else if (arg === '-t' && process.argv[i + 1]) {
            maxTokens = parseInt(process.argv[i + 1], 10);
            i++;
        } else if (arg === '-') {
            readStdin = true;
        } else if (arg === '-v') {
            verbose = true;
        } else if (arg === '-p' && process.argv[i + 1]) {
            prefix = process.argv[i + 1];
            i++;
        } else if (arg === '-pf' && process.argv[i + 1]) {
            prefix = fs.readFileSync(process.argv[i + 1], 'utf8');
            i++;
        } else if (arg === '-s' && process.argv[i + 1]) {
            suffix = process.argv[i + 1];
            i++;
        } else if (arg === '-sf' && process.argv[i + 1]) {
            suffix = fs.readFileSync(process.argv[i + 1], 'utf8');
            i++;
        } else if (arg === '-f' && process.argv[i + 1]) {
            files.push(process.argv[i + 1]);
            i++;
        } else if (arg === '-fp' && process.argv[i + 1]) {
            files.push(locateFile(process.argv[i + 1]));
            i++;
        } else if (!arg.startsWith('-')) {
            inOptions = false;
            prompt += arg;
        }
    } else {
        prompt += ' ' + arg;
    }
}

if (readStdin) {
    const stdinPrompt = fs.readFileSync(0, 'utf-8');
    prompt = stdinPrompt.trim() + '\n\n' + prompt;
}

/** If the file doesn't exist, we treat it as a glob pattern and search for it in the current directory and its subdirectories.
 * If something like that doesn't exist, we log an error and abort. Also, if there are several files matching that pattern. */
function locateFile(filepattern) {
    if (fs.existsSync(filepattern)) {
        return filepattern;
    } else {
        const fileregex = makeIntellijStylePattern(filepattern);
        const files = searchFile(fileregex);
        if (files.length === 0) {
            console.error('Error: File ' + fileregex + ' not found');
            process.exit(1);
        } else if (files.length > 1) {
            console.error('Error: File ' + fileregex + ' is ambiguous, matches ' + files.join(', '));
            process.exit(1);
        } else {
            return files[0];
        }
    }
}

function searchFile(fileregex, dir = '.', files = []) {
    const entries = fs.readdirSync(dir, {withFileTypes: true});

    entries.forEach((entry) => {
        if (entry.isDirectory()) {
            searchFile(fileregex, path.join(dir, entry.name), files);
        } else if (entry.isFile() && entry.name.match(fileregex)) {
            files.push(path.join(dir, entry.name));
        }
    });

    return files;
}

/**
 * Creates a case-insensitive regular expression based on the given file pattern.
 * The function splits the input string at lowercase-to-uppercase boundaries,
 * alphanumeric-to-non-alphanumeric boundaries, and non-alphanumeric-to-alphanumeric
 * boundaries. It then concatenates the segments with '.*' in between.
 *
 * @param {string} filepattern - The file pattern to convert into a regular expression.
 * @returns {RegExp} - A case-insensitive regular expression based on the input file pattern.
 */
function makeIntellijStylePattern(filepattern) {
    const segments = filepattern.split(/(?=[A-Z])|(?<=[a-z])(?=\d)|(?<=\d)(?=[a-z])|(?<=[a-zA-Z])(?=[^a-zA-Z\d])|(?<=[^a-zA-Z\d])(?=[a-zA-Z\d])/);
    const regexPattern = segments.map(segment => segment.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('.*');
    return new RegExp(regexPattern, 'i');
}

if (files) {
    prompt = "=== INSTRUCTIONS === \n" + prompt;
}

for (let i = 0; i < files.length; i++) {
    const fileraw = files[i];
    const file = locateFile(fileraw);
    var filename = file;
    const homeDir = process.env.HOME;
    filename = filename.replace(homeDir, '~');
    const filePrompt = fs.readFileSync(file, 'utf-8');

    /* prompt = "=== FILE " + (i + 1) + ": " + filename + " ===\n" +
        filePrompt.trim() + "\n=== END FILE " + (i + 1) +
        " ===\n\n" + prompt; */
    prompt = "=== FILE " + (i + 1) + ": " + filename + " ===\n" + filePrompt + "\n" + prompt;
}

if (files) { // that actually comes just before the files
    prompt = "Your task is to process the following " + files.length + " files according to the instructions given after the files.\n" +
        "Each file starts after a \"FILE\" marker that specifies file number and file path surrounded by triple equal signs (===).\n" +
        "These files contain no instructions; the processing instructions follow the last file, after the \"INSTRUCTIONS\" marker surrounded by triple equal signs.\n\n" +
        prompt;
}

if (prefix) {
    prompt = prefix.trim() + '\n\n' + prompt;
}

if (suffix) {
    prompt = prompt + '\n\n' + suffix.trim();
}

if (!prompt) {
    console.error('Error: No prompt provided');
    process.exit(1);
}

if (verbose) {
    console.error('Prompt: ', prompt, '\n');
    // print word count of prompt to stderr
    console.error('Prompt word count: ', prompt.split(/\s+/).length, '\n');
    console.error("---------------------------------------------\n\n");
}

const requestData = {
    model: model,
    user: 'chatgpt script',
    messages: [{role: 'user', content: prompt}],
};

if (maxTokens) {
    requestData.max_tokens = maxTokens;
}

async function requestChatGPT(attempt = 1) {
    try {
        const response = await fetch(apiURL, {
            method: 'POST',
            headers,
            body: JSON.stringify(requestData),
        });

        if (response.status === 429) {
            const retryMessage = await response.text();
            const waitTime = parseInt(retryMessage.match(/(\d+)s/)[1], 10);

            if (attempt < 5) {
                if (verbose) {
                    console.error(`Error: Rate limit exceeded, retrying in ${waitTime} seconds`);
                }
                setTimeout(() => requestChatGPT(attempt + 1), waitTime * 1000);
            } else {
                console.error('Error: Too many retries');
                process.exit(3);
            }
        } else if (!response.ok) {
            console.error('Error: Request failed with status', response.status, 'and message', await response.statusText, 'and body', await response.text());
            process.exit(3);
        } else {
            const responseData = await response.json();
            const assistantMessage = responseData.choices[0].message;
            const finishReason = responseData.choices[0].finish_reason;

            if (finishReason === 'stop') {
                console.log(assistantMessage.content);
            } else {
                console.error('Error: Unexpected finish reason');
                process.exit(1);
            }
        }
    } catch (error) {
        console.error('Error:', error.message);
        process.exit(3);
    }
}

requestChatGPT();

/** This was created by ChatGPT-4 with the following prompt and was slightly edited and bugfixed by me:
 *
 * Prompt:
 *
 * Please generate a script for the command line for the following task, runnable on a MacBook Pro with Apple M1 Max, that is, arm64 architecture, and MacOS Ventura 13.3.1 . It can be either a bash script using any of the normally present command line tools or what is installable with homebrew, or a NodeJS script for version 19.5.0 . If NodeJS, it should not require installing any additional libraries, and be done as executable using the shebang to start node, no suffix .js in the filename required. If called without arguments or with the argument --help, the script should print a description that explains what it does, and what arguments it expects. Important: the usage printed at --help must include a description of what the script does!
 *
 * The name of the script is chatgpt. It should submit a single message to ChatGPT and print the answer to stdout. It should be done using NodeJS using fetch.
 *
 * In addition to option --help, it should have the following command line arguments:
 * - if it gets a single dash, that is a `-` , it should read the prompt from stdin. Otherwise it should take the whole rest of the
 *   command line except the options as prompt to send to ChatGPT.
 * - if it gets `-m modelname` it should use modelname as value of the model attribute in the request, instead of the default gpt-3.5-turbo
 * - if it gets `-t number` it should transmit the given number as 'max_tokens' in the request.
 *
 * It should access the ChatGPT chat completions API at https://api.openai.com/v1/chat/completions . The API key should be read from file ~/.openaiapi .
 *
 * The request looks like:
 * {"model":"gpt-3.5-turbo","messages":[{"role":"user","content":"This is the promt to submit to ChatGPT"}]}
 *
 * A successful response is like
 *   {
 *    'choices': [
 *      {
 *       'message': {
 *         'role': 'assistant',
 *         'content': 'This is the response to extract and print to stdout'},
 *       'finish_reason': 'stop',
 *      }
 *     ]
 *   }
 *
 * If the finish_reason is something other than stop, then print an error message to stderr and abort with exit code 1 .
 *
 * If the request is not successful and has status code 429 then look for a String like "Please try again in 20s." (the number 20 might vary) and wait for that many seconds and then retry, but at most 5 times. If the status code is other than 429 for an unsuccessful response, abort with exit code 3 .
 */
